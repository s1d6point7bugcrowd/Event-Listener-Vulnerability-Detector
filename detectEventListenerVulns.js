const axios = require('axios');
const { JSDOM } = require('jsdom');

// ANSI escape codes for coloring
const colors = {
    reset: "\x1b[0m",
    yellow: "\x1b[33m",
    bold: "\x1b[1m",
};

// Utility function to detect adding event listeners with unsanitized user input
function detectUnsafeEventListener(jsCode) {
    const eventListenerRegex = /\.addEventListener\s*\(\s*['"][a-zA-Z]+['"]\s*,\s*(\w+)/;
    return jsCode.split('\n').map((line, index) => {
        const handlerMatches = line.match(eventListenerRegex);
        if (handlerMatches) {
            const handlerName = handlerMatches[1];
            const userInputRegex = new RegExp(`${handlerName}\\s*\\(([^)]*)\\)`);
            const userInputMatches = jsCode.match(userInputRegex);
            if (userInputMatches) {
                const params = userInputMatches[1].split(',').map(param => param.trim());
                if (params.some(param => param.includes('userInput') || param.includes('document'))) {
                    return { line: index + 1, code: line, handlerName };
                }
            }
        }
        return null;
    }).filter(Boolean);
}

// Utility function to detect missing removeEventListener
function detectMissingRemoveEventListener(jsCode) {
    const addListenerRegex = /\.addEventListener\s*\(/g;
    const removeListenerRegex = /\.removeEventListener\s*\(/g;
    const addListeners = jsCode.match(addListenerRegex) || [];
    const removeListeners = jsCode.match(removeListenerRegex) || [];
    if (addListeners.length > removeListeners.length) {
        return jsCode.split('\n').map((line, index) => addListenerRegex.test(line) ? { line: index + 1, code: line } : null).filter(Boolean);
    }
    return [];
}

// Function to analyze JavaScript code for vulnerabilities
function analyzeJavaScript(jsCode) {
    const issues = [];

    const eventListenerIssues = detectUnsafeEventListener(jsCode);
    if (eventListenerIssues.length > 0) {
        issues.push({ type: 'Event listener added with unsanitized user input', details: eventListenerIssues });
    }

    const memoryLeakIssues = detectMissingRemoveEventListener(jsCode);
    if (memoryLeakIssues.length > 0) {
        issues.push({ type: 'Potential memory leak: addEventListener without corresponding removeEventListener', details: memoryLeakIssues });
    }

    return issues;
}

// Function to analyze HTML and JavaScript content
async function analyzeContent(content, baseURL) {
    const dom = new JSDOM(content);
    const scripts = dom.window.document.querySelectorAll('script');

    let issues = [];
    for (const script of scripts) {
        if (script.src) {
            try {
                const scriptURL = new URL(script.src, baseURL).href;
                const response = await axios.get(scriptURL);
                issues = issues.concat(analyzeJavaScript(response.data));
            } catch (error) {
                console.error(`Error fetching external script: ${script.src}`, error);
            }
        } else {
            issues = issues.concat(analyzeJavaScript(script.textContent));
        }
    }

    return issues;
}

// Function to fetch and analyze the URL
async function analyzeURL(url) {
    try {
        const response = await axios.get(url);
        const content = response.data;
        const issues = await analyzeContent(content, url);
        if (issues.length === 0) {
            console.log('No issues detected.');
        } else {
            const uniqueIssues = {};
            console.log('Issues detected:');
            issues.forEach(issue => {
                issue.details.forEach(detail => {
                    const key = `${issue.type}:${detail.line}`;
                    if (!uniqueIssues[key]) {
                        uniqueIssues[key] = { type: issue.type, line: detail.line, code: detail.code.trim(), handlerName: detail.handlerName };
                    }
                });
            });
            Object.values(uniqueIssues).forEach(issue => {
                console.log(`- ${issue.type}`);
                console.log(`  Line ${issue.line}: ${issue.code.length > 80 ? issue.code.slice(0, 77) + '...' : issue.code}`);

                // Instructions for further testing
                if (issue.type === 'Event listener added with unsanitized user input') {
                    console.log(`${colors.yellow}${colors.bold}  [Action] This could lead to XSS if user input is not properly sanitized. Attempt to inject malicious code to test further.`);
                    console.log(`  [Injection Point] Handler function: ${issue.handlerName}`);
                    console.log(`  [Suggested Payload] Try injecting: <img src=x onerror=alert(1)> or similar payloads depending on the context.`);
                    console.log(`  [Action] If you can successfully execute JavaScript via this input, report it immediately as a critical issue (VRT: P1 - Cross-Site Scripting).${colors.reset}`);
                } else if (issue.type === 'Potential memory leak: addEventListener without corresponding removeEventListener') {
                    console.log(`${colors.yellow}${colors.bold}  [Action] This may cause performance issues over time. Confirm if there are multiple event listeners added without removal.`);
                    console.log(`  [Action] If confirmed, document the scenario and report it as a significant issue (VRT: P3 - Denial of Service - Resource Exhaustion).${colors.reset}`);
                }
            });
        }
    } catch (error) {
        console.error('Error fetching the URL:', error);
    }
}

// Main function to run the analysis
async function main() {
    const url = process.argv[2];
    if (!url) {
        console.error('Usage: node detectEventListenerVulns.js <url>');
        process.exit(1);
    }

    await analyzeURL(url);
}

main();
